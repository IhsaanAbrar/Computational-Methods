from typing import List, Tuple, Optional

class Graph:
    def __init__(self, vertices: int):
        self.V = vertices
        self.graph: List[Tuple[int, int, float]] = []

    def add_edge(self, u: int, v: int, w: float) -> None:
        self.graph.append((u, v, w))

    @staticmethod
    def _find(parent: List[int], i: int) -> int:
        if parent[i] != i:
            parent[i] = Graph._find(parent, parent[i])
        return parent[i]

    @staticmethod
    def _union(parent: List[int], rank: List[int], x: int, y: int) -> None:
        if rank[x] < rank[y]:
            parent[x] = y
        elif rank[x] > rank[y]:
            parent[y] = x
        else:
            parent[y] = x
            rank[x] += 1

    def kruskal_mst(self) -> Tuple[List[Tuple[int, int, float]], float]:
        result: List[Tuple[int, int, float]] = []
        e = 0
        i = 0
        edges = sorted(self.graph, key=lambda item: item[2])
        parent = list(range(self.V))
        rank = [0] * self.V
        while e < self.V - 1 and i < len(edges):
            u, v, w = edges[i]
            i += 1
            x = self._find(parent, u)
            y = self._find(parent, v)
            if x != y:
                result.append((u, v, w))
                e += 1
                self._union(parent, rank, x, y)
        if e != self.V - 1:
            raise ValueError("No MST exists (graph is disconnected).")
        total = sum(w for _, _, w in result)
        return result, total


def graph_from_distance_matrix(mat: List[List[Optional[float]]],
                               zero_means_no_edge: bool = True,
                               symmetric_undirected: bool = True) -> Graph:
    n = len(mat)
    g = Graph(n)
    for i in range(n):
        for j in range(n):
            if i == j:
                continue
            w = mat[i][j]
            if w is None:
                continue
            if zero_means_no_edge and (w == 0):
                continue
            if symmetric_undirected and j <= i:
                continue
            g.add_edge(i, j, float(w))
    return g


if __name__ == "__main__":
    g = Graph(4)
    g.add_edge(0, 1, 10)
    g.add_edge(0, 2, 6)
    g.add_edge(0, 3, 5)
    g.add_edge(1, 3, 15)
    g.add_edge(2, 3, 4)
    mst_edges, cost = g.kruskal_mst()
    print("Edges in the constructed MST:")
    for u, v, w in mst_edges:
        print(f"{u} -- {v} == {w}")
    print("Minimum Spanning Tree", cost)
    mat = [
        [0, 10, 6, 5],
        [10, 0, 0, 15],
        [6, 0, 0, 4],
        [5, 15, 4, 0],
    ]
    g2 = graph_from_distance_matrix(mat)
    mst2, cost2 = g2.kruskal_mst()